## 													Backtracking

The backtracking is commonly applied in case of finding out all solutions and usually embodied by recursion. To find out all solutions, I keep choosing among options to see if combinations meet requirements. 

Below is the basic framework of backtracking with pseudocode.

```cpp
void foo(...) {
  for(;;) {   // traverse options
    // determine whether choose this option (whether update path)
    foo(...);
    // undo update of path made before in this iteration
  }
}
```

*The main part of the recursive function is generally a for loop that traverse potential options. In each iteration, the option may get tested, then if the option is chosen(update the path) and the path still does not reach the end point after update, I make a recursive call to further build up the path based on choices made before; but if the end point is reached, I store the path and stop recursion. It's important to realise that, options traversed within for loop, are mutually exclusive, so they cannot affect each other (i.e. if option A is chosen, then option B's status should be unchosen). It's the reason why in for loop, before next iteration, current iteration should undo update of path it made before.* 

Note that since the stack zone of the callee is released when it returns, the caller does not need to take care of items in stack generated by callee.  When the process returns from a chain of recursive calls, PC is set as the beginning address of the first instruction of code block 'undo update of path made before in this iteration'. 

I will elaborate Leetcode problems to examplify above concepts. 

Case1: [LeetCode 216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/) 

Reminder that i+1 is the first argument passed to the recursive call. This is saying no looking back to prevent duplication. 

My solution:

```cpp
class Solution {
public:
    vector<vector<int>> result_;
  
    vector<int> path_;
  
    vector<vector<int>> combinationSum3(int k, int n) {
        recur(1, k, n);
        return result_;
    }
  
    void recur(int i, int k, int n) {
        for(i; i<10; i++) {
            path_.push_back(i);
            if(path_.size() == k) {
                int s = 0;
                for(int j=0; j<k; j++) {
                    s += path_[j];
                }
                if(s==n) {
                    result_.push_back(path_);
                }
            } else {
                recur(i+1, k, n);
            }
            path_.pop_back();     
        }  
    }
};
```

Case2: [LeetCode 78. Subsets](https://leetcode.com/problems/subsets/) 

My solution:

```cpp
class Solution {
public:
    vector<vector<int>> result_;

    vector<int> path_;

    vector<vector<int>> subsets(vector<int>& nums) {
        result_.push_back(path_);
        int n = nums.size();
        recur(0, n, nums);
        return result_;
    }

    void recur(int i, int n, vector<int>& nums) {
        for(i; i<n; i++) {
            path_.push_back(nums[i]);
            result_.push_back(path_);
            recur(i+1, n, nums);
            path_.pop_back();
        }
    }
};
```

Case3: [LeetCode 47. Permutations II](https://leetcode.com/problems/permutations-ii/) 

In this case, I introduced a handy vector chosen_ to dynamically record which options are chosen, sorted nums before using it so that any duplication is consecutive. The key statement proventing duplication is ``` if(i>0 && nums[i-1]==nums[i] && chosen_[i-1]==false) continue;``` Reminder that in for loop, i goes from 0 to the upper limit, so index i-1 is tested before index i. ```chosen_[i-1]``` taking false implies that index i-1 is already examined in the for loop, since each iteration of for loop restores it's altered ```chosen_[i]``` back to false before turning into the next iteration. If ```nums[i-1]==nums[i]```, then they make the same effect from the angle of using for loop to pick out one. In combination, the above statement ensures to forgo such case to avoid duplication.

My solution:

```cpp
class Solution {
public:

    vector<int> path_;

    vector<vector<int>> result_;

    vector<bool> chosen_;

    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for(int i = 0; i<nums.size(); i++) {
            chosen_.push_back(false);
        }
        recur(nums);
        return result_;
    }

    void recur(vector<int>& nums) {
        for(int i=0; i<nums.size(); i++) {
            if(chosen_[i]==false) {     // if it's already chosen I cannot take it into account
                if(i>0 && nums[i-1]==nums[i] && chosen_[i-1]==false)
                    continue;
                path_.push_back(nums[i]);
                chosen_[i]=true;
                if(path_.size()==nums.size()) {
                   result_.push_back(path_);
                } else recur(nums);
                path_.pop_back();
                chosen_[i]=false;
            }
        }
    }
};
```

Case4: [LeetCode 51. N-Queens](https://leetcode.com/problems/n-queens/description/) 

Firstly I determine my for loop should traverse one row to put one queen in cell if possible, because one row can have one Queen at most. Obviously, my recursion should go forward row by row, based on choices made in previous rows. 

My solution:

```cpp
class Solution {
public:
    vector<vector<string>> result;

    vector<vector<string>> solveNQueens(int n) {
        string row(n, '.');
        vector<string> path(n, row);
        recur(0, n, path);
        return result;
    }

    void recur(int i, int n, vector<string>& path) {
        for(int j = 0; j<n; j++) {
            if(isValid(i, j, path, n)) {
                path[i][j] = 'Q';
                if(i<n-1) {
                    recur(i+1, n, path);
                } else {
                    result.push_back(path);
                }
                path[i][j] = '.';
            }
        }
    }

    bool isValid(int i, int j, vector<string>& path, int n) {
        for (int i_ = 0; i_ < i; i_++) {
            if (path[i_][j] == 'Q') 
                return false;
        }
        for (int i_ = i - 1, j_ = j - 1; i_ >= 0 && j_ >= 0; i_--, j_--) {
            if (path[i_][j_] == 'Q') 
                return false;
        }
        for (int i_ = i - 1, j_ = j + 1; i_ >= 0 && j_ < n; i_--, j_++) {
            if (path[i_][j_] == 'Q') 
                return false;
        }
        return true;
    }

};
```

